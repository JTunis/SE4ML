\section{Generate Test Cases}
\marginnote{Most books talk about correct solutions only.  Few books
  talk about incorrect methods and why they are wrong.  This book
  takes a different approach: we assume that mistakes are unavoidable
  and explain strategies to prevent, detect, and correct the mistakes.
}

Lacking test cases of known properties is one common problem in
developing software for machine learning.  The purpose of machine
learning is to recognize unknown patterns in data; thus, we do not
know the patterns in advance.  How can we know that the programs are
correct?  If we do not know that the programs are correct, how do we
know the patterns discovered by the programs are correct?  Two methods
are commonly used:
\begin{enumerate}
\item Creating simple test cases manually with known properties.

\item Adopting widely used test cases whose properties have already
  been studied.
\end{enumerate}
The first methods is restricted to only very small test cases that are
unlikely to have sophisticated patterns needed to test computer
programs.  The second methods, in contrast, may sophisticated patterns
but the data may be too complex for identify problems in the programs.

\index{test case generator}

\marginnote{When developing programs, it is common to test using cases
  of known properties generated by computer programs (called {\it test
    case generators} in this book).  }

This book suggests the third approach: write another program (or
several programs) to generate the test cases of known properties.
More specifically, for this problem, we can write a program that
generates $n$ data points in $k$ clusters ($n > k$).  Since the data
points are generated intentionally, it is easy to test whether a
k-mean program is correct.

Writing a test case generator, however, is not trivial because the
generator has to consider many different possible properties of data
collected in different scenarios. It is likely that different
generators would be needed in different scenarios. This section
explains one generator. Readers may need to change this generator to
meet different needs.  This generator has the following input
arguments:\marginnote{Determining the inputs is an important part of
  designing software.}

\begin{itemize}
\item Number of dimension ($p$ in the explanation).  Each data point
  is a $p$-dimensional vector. The minimum value is 1.

\item Number of clusters (called $m$ in this program).  This program
  restricts that $m$ must be greater than two.  The program
  intentionally uses a different symbol ($m$) to distinguish from the
  value $k$ given to the clustering program to be tested.

\item Minimum numbers of data points per cluster (called $q$ in this
  program).  This program restricts that $q$ must be at least three.

\item Maximum numbers of data points per cluster (called $r$ in this
  program). Obviously, $r$ must be greater than $q$.

\end{itemize}  

All these arguments are positive integers.  The programs in this
chapter handles integers only because floating-point numbers have
limited precision and sometimes give suprising results.  The number of
data points $n$ is between $m q$ and $m r$.
\marginnote{Chapter~\ref{ch:floatingpoint} has more details about how
  the limited precision may affect results in analysis.}  This program
generates two output files: {\tt data.txt} and {\tt cluster.txt}.  The
first file has $n$ lines and each line has $p$ integers.  The second
file also has $n$ lines; each line has the same $p$ integers,
following by one integer between $0$ and $m - 1$ to indicate which
cluster this line belongs to.

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\progpath/unsupervised/kmean/testgen/main.py}
\end{tt}
\nolinenumbers

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\progpath/unsupervised/kmean/testgen/testgen.py}
\end{tt}
\nolinenumbers

Clustering {\it high-dimensional data} is frequently used. Consider
the following examples:



Chapter~\ref{ch:clusterlimit}
will explain some other factors for consideration.
