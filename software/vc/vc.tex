\chapter{Version Control}

\section{Software Versions}

No writer can finish a good book in one shot. A book needs to be
writen section by section and chapter by chapter. The writing is
likely reviewed and revised multiple times. If you watch a movie DVD,
you can find {\it Deleted Scenes}--- the sections that have been made
but never used in the actual movie.  Any non-trivial work needs to be
created gradually and improved over and over again before it is ready.
Developing software is no different: functionality is added
gradually. Sometimes, finished functions need to change because
customers' needs have changed, competitors have introduced new
features and modifications are needed, new regulations are announced,
or new standards are issued. All of these mean that software must be
developed in small pieces; these pieces are called {\it version}.

There is no widely accepted definition of a version, just like there
is no specific definition what should be considered as a chapter in a
book. One may consider each additional line as a new version while
another may consider a completely implemented and fully tested feature
as a version. Generally speaking, a version should be self-contained
and complete unit, like a section or a chapter in a book.  The tools
that manage versions are called {\it version control}.  When multiple
work together, version control becomes essential to ensure proper
coordination.

There are many version control systems, such {\tt CVS} (concurrent
version system) and {\tt SVN} (subversion).  This book uses {\tt git}
for version control. It is a {\it distributed} version control system,
meaning that there can be two types of {\it repositories}: One is on
each user's computer; the other is shared by all users. The advantage
of a distributed version control system will become clear after
explaining how people collaborate developing software.

The version control system {\tt git} is a set of programs managing
files.  You can run {\tt git} on your own computer. You can also set
up a {\tt git} server shared by multiple people. Alternatively, you
can use websites that offer version control functions; examples
include {\tt github.com} and {\tt bitbucket.org}.  This book uses {\tt
  github} as an example.  You can find entire books talking about {\tt
  git} as well as thousands of web postings about how to use {\tt
  github}. {\tt git} has many different functions and {\tt github}
offers many different ways to accomplish the same goals.  This book
does not intend to replace those materials.  Instead, this book
provides enough details for common needs.  Readers interested knowing
more can easily find additional documentations.
\marginnote{The authors are users of  {\tt github.com}
  and have no other connection with {\tt github.com}.}

\section{\tt github}

This book chooses {\tt github} for three reasons: (1) It is widely
used.  (2) It is free for education purposes. (3) It is supported by
many tools other than the {\tt github} website.
Figure~\ref{fig:github12} shows the website of {\tt github} and the
portal for an education account.

\begin{figure}[h] \centering
 \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github1.png}}
  \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github2.png}}
\caption{(a) {\tt github} website. (b) Students and teachers can apply for free repositories.}
\label{fig:github12}
\end{figure}

Signing up in {\tt github} is easy, as shown in
Figure~\ref{fig:github34} (a).  After creating an account, a
repository can be created as shown in Figure~\ref{fig:github34} (b).
This website has many options: the name of the repository, whether it
is public or private, whether to initialize the repository with {\tt
  README}, etc.


\begin{figure}[h] \centering
 \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github3.png}}
  \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github4.png}}
\caption{(a) Create an account in {\tt github}. (b) Create a
  repository.}
\label{fig:github34}
\end{figure}

\begin{figure}[h] \centering
   \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github5.png}}
   \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github6.png}}
\caption{(a) A new repository. (b) The repository has been created.}
\label{fig:github56}
\end{figure}

\marginnote{Is {\tt git} case sensitive? The correct answer
  is ``it is complicated''. A short answer is ``No'': you
  should treat {\tt git} as case insensitive. Do not have two
files whose names are different by cases only.}

Figure~\ref{fig:github56} (a) shows the options for creating a new repository:


\begin{itemize}
\item Repository name: pythonexamples
\item Description: sample programs written in Python
\item Public
\item Check ``Initialize this repository with a README''
\item Select ``Add .gitignore: Python''
\item Select ``Add a license: Apache License 2.0''
\end{itemize}


Figure~\ref{fig:github56} (b) shows the repository after it has been
created.  As can be seen on the website, there are many options
changing this repository.  For example, it is possible adding new
files or uploading files. It is also possible editing an file by
clicking the pen icon.

\section{Clone a Repository}

A more common way of using a repository, however, is to {\it clone} the
repository on another computer, as illustrated in Figure~\ref{fig:gitclone}.

\index{git!clone}

\begin{figure}[h] \centering
{\includegraphics[width=3in]{\thischapterpath/figures/gitclone.png}}
\caption{Using {\tt git clone} command creates a repository on another computer.}
\label{fig:gitclone}
\end{figure}

To clone a repository, it is necessary knowing the {\it path} in {\tt
  github}.  Figure~\ref{fig:github7} shows the path of the repository.

\begin{figure}[h] \centering
{\includegraphics[width=3in]{\thischapterpath/figures/github7.png}}
\caption{Cloning a repository may use HTTPS or SSH.}
\label{fig:github7}
\end{figure}


\clearpage

\index{git!clone}
To clone the repository, starts a {\it Terminal} in Linux
and type the {\tt git clone} command. In the following
example, {\tt \$} is the {\it command prompt} for the Terminal.

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git clone https://github.com/yhluprog/pythonexamples.git
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

The command clones the repository and the following message is shown:

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
Cloning into 'pythonexamples'...
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 5 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (5/5), done.
Checking connectivity... done.
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

After cloning the repository, a directory (also called folder) with
the name {\tt pythonexamples} is created.  This can be shown
using the {\tt ls} command:

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ ls
pythonexamples/
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

Inside this directory, there are already two files: {\tt
  LICENSE} and {\tt README.md}. The is a hidden file {\tt .gitignore}.
It is hidden because it starts with {\tt .} and is not shown by the
{\tt ls} command. To show a hidden file, it is necessary using the
{\tt ls -a} command. Additionally, a hidden directory (ending with
{\tt /}) called {\tt .git} is also shown.

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ cd pythonexamples/
$ ls -a
./  ../  .git/	.gitignore  LICENSE  README.md
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

Enter the directory using the {\tt cd} command
and use the {\tt ls} command to see the files and directories.

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ cd .git
$ ls
branches/  config  description	HEAD  hooks/  index  
info/  logs/  objects/  packed-refs  refs/
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}


Among them, {\tt config} stores the information about
the remote repository.  The {\tt more} command can show
the content of the file:

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ more config
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/yhluprog/pythonexamples.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\index{git!clone}
The line starting with {\tt url} is the path used in {\tt git clone}.
The concept of {\it branch} will be explained later in this chapter.

\section{Commit and Push}

\marginnote{Modifying {\tt LICENSE} is not recommended.}

There are many different methods modifying a repository.  The first
method modifies an existing file.  Use a text editor and add the
following line to {\tt README.md}:

\begin{verbatim}
This repository demonstrates how to use commit, push, and branch.
\end{verbatim}

\index{git!commit}
After adding this line, use the {\tt git commit} command to show which file
has been changed:

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git commit
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
	modified:   README.md
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

What does this mean? It says a file {\tt README.md} has been changed
but it has not been committed. The next question is the difference
between changes and commit.  Modifications are often reviewed and
revised multiple times; these changes are transient and do not need to
be recorded in the repository.  When the modifications are
satisfactory, the file is ready to ``take a snapshot'' by creating a
new version.  The command to take a snapshot is {\tt git commit}.
\index{git!commit}

The earlier {\tt git commit} shows the candidate(s) for commit.  A
candidate can be a files that has been modified ({\tt README.md} in
this example).  This command has not committed any changes yet and has
not created a new version. To commit the change of a specific file, it
is necessary adding the file's name as shown in the following example

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git commit -m "add a line" README.md 
[master 26317f0] add a line
 1 file changed, 2 insertions(+)
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\marginnote{It is a good habit of using meaningful commit
  messages because these messages can be searched to
  find the right version.}

In this command, {\tt -m} means the commit message and this commit
message is ``add a line''.  The name of the file, {\tt README.md}, is
included to indicate which file to take a snapshot and a new version
is created.

\index{git!commit}
\begin{figure}[h] \centering
{\includegraphics[width=2.5in]{\thischapterpath/figures/gitcommit.png}}
\caption{After several changes, {\tt git commit} creates a new version
  and store it in the local repository.}
\label{fig:gitcommit}
\end{figure}

This new version is visible at only the local repository, not the remote
repository (in {\tt github}).  To make the changes visible in {\tt github},
another command {\tt git push} is needed.
\index{git!push}

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git push
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 343 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/yhluprog/pythonexamples.git
   883333a..26317f0  master -> master
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\marginnote{A public repository (or open-source) repository allows
  everyone to read but only permitted people (determined by the owner
  of the repository) can write.}

\index{git!push}
\index{git!commit}
The {\tt git push} command needs an user name and the password because
it does not allow everyone to push and modify the repository.  The
rest of the message can be ignored for now.  Figure~\ref{fig:gitpush}
shows the typical workflow of using {\tt github}: Use {\tt git push}
to modify the remote repository after several {\tt git commit}
commands creating new versions on the local repository.

\begin{figure}[h] \centering
{\includegraphics[width=2.5in]{\thischapterpath/figures/gitpush.png}}
\caption{Typical workflow of using {\tt github}}
\label{fig:gitpush}
\end{figure}

\clearpage

Figure~\ref{fig:github8} shows the {\tt github} website after {\tt git
  push}.  The changes are clearly marked: if a new line is added, a
``+'' sign is added in front.  Similarly, if a line is deleted, a
``-'' sign is added in front (not shown in this example).

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github8.png}}
\caption{The website of {\tt github} shows the change.}
\label{fig:github8}
\end{figure}

\section{Set Up SSH Key}


\section{Add and Remove Files}

The examples so far only modify an existing file: {\tt README.md}
added by {\tt github} when the repository is created.  This section
explains how to add and remove files or directories.  Use a text
editor to create the following simple Python program (without the line
numbers).

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\thischapterpath/code/hello.py}
\end{tt}
\nolinenumbers

\index{git!add}
\index{git!commit}

The {\tt git add} command informs the intention of adding this file to
the repository.  It is important to know that this file has not been
added yet.  To actually add this file, it is necessary using
the {\tt git commit} command followed by a message and the name of
the file to be added, as shown below.

\vspace{0.2in}

\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git add hello.py
$ git commit -m "add a new file to print hello" hello.py
[master 1ed761d] add a new file to print hello
 1 file changed, 7 insertions(+)
 create mode 100755 hello.py
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

The {\tt git push} command modifies the repository in {\tt github}

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git push
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 365 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/yhluprog/pythonexamples.git
   26317f0..1ed761d  master -> master
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github10.png}}
\caption{The added file {\tt hello.py} is listed in {\tt github}.}
\label{fig:github10}
\end{figure}

A directory can be created using the {\tt mkdir} command in
Linux. Adding a file in a directory automatically to the repository
adds the directory.

To remove a file, use the {\tt git rm} command, followed by {\tt git commit}.
If {\tt git push} is used, the file is also removed from {\tt github}.

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git rm hello.py
rm 'hello.py'
$ git commit -m "remove the file" hello.py
[master 3357bae] remove the file
 1 file changed, 7 deletions(-)
 delete mode 100755 hello.py
$ git push
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Counting objects: 2, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 221 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/yhluprog/pythonexamples.git
   1ed761d..3357bae  master -> master
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

It is important to know that the deleted file does not disappear. It is still
stored in the history of the repository. In {\tt github}, clicking the commit
history shows all the changes over time, as shown in Figure~\ref{fig:github11}.

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github11.png}}
\caption{The commit history.}
\label{fig:github11}
\end{figure}

\index{git!log}
It is also possible using the {\tt git log} command to see the history in
the reverse chronological order (the most recent first):

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$  git log
commit 3357baed98088aacc452a1135ff16739fe64cab6
Author: XXXX
Date:   YYYY

    remove the file

commit 1ed761dbd9a70c6b38a7d788dd3afc19d33f3b9a
Author: XXXX
Date:   YYYY

    add a new file to print hello

commit 26317f089e64f8fd10b7d4a5dc96fad1bdccab7f
Author: XXXX
Date:   YYYY

    add a line

commit 883333a9c3177b5e3d826addb15b8ebf4caf7b8c
Author: XXXX
Date:   YYYY

    Initial commit
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\section{Collaboration using {\tt github}}

Does does ``hub'' in {\tt github} mean? Think of it as an airline hub
or a bus hub, where travellers come from many different places in
order to change flights or bus lines.  Similarly, {\tt github} allows
collaborate to share and exchange.  Adding collaborators would be
easy, by clicking {\tt Settings} and {\tt Collaborators}, as shown
in Figure~\ref{fig:github9}.

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github9.png}}
\caption{Add collaborators to a repository.}
\label{fig:github9}
\end{figure}

Two people may share and modify the same repository in {\tt github} in
the way depicted in Figure~\ref{fig:githubcollaborate}.  In this
figure, the numbers in black ovals indicate steps within individual's
local repository.  The numbers in white ovals indicate steps involving
the remote repository.
Figure~\ref{fig:githubcollaborate} shows two people start from the
same remote repository. This is not necessary.  It is possible
to clone the remote repository after many modifications have already
been made by another person.

Each person starts by cloning the same repository in {\tt
  github}. After cloning, each person can work independently without
interfering with each other. Each person can also commit multiple
times creating multiple versions on their local repositories.  When
one decides it is time to share a version with the other person, this
version is pushed to the shared repository in {\tt github}.  Before
anything is pushed, the local repository should be updated by using
the {\tt git pull} command to ensure any changes by the other person
is reflected. Otherwise, the changes by the other person may be erased
by the new push.  Even though the erased changes can be recovered,
pushing without pulling first creates unnecessary trouble and is
impolite.

\marginnote{Always do {\tt git pull} before {\tt git push}, unless it
  is already known that nobody has pushed anything after a repository
  is cloned.  }

\index{git!pull}

This following is an example of running the {\tt git pull} command
while writing this book. It says two files, {\tt README.md} and {\tt
  python.tex}, have been modified by a collaborator (maybe several
collaborators).

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git pull
remote: Enumerating objects: 16, done.
remote: Counting objects: 100% (16/16), done.
remote: Compressing objects: 100% (11/11), done.
remote: Total 16 (delta 7), reused 14 (delta 5), pack-reused 0
Unpacking objects: 100% (16/16), done.
From https://github.com/PurdueCAM2Project/SE4ML
   7e25147..5051695  master     -> origin/master
 * [new tag]         v0.6       -> v0.6
 * [new tag]         v0.7       -> v0.7
 * [new tag]         v0.6.1     -> v0.6.1
Updating 7e25147..5051695
Fast-forward
 README.md                  |   8 ++--
 software/python/python.tex | 221 ++++++-----------
 2 files changed, 101 insertions(+), 128 deletions(-)
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}



Now is a good time explaining the advantage of distributed version
control systems like {\tt git}.  Figure~\ref{fig:githubcollaborate}
shows three repositories: one remote and shared in {\tt github} and
two local repositories by two different people. These two people can
change the files on their local repositories without affecting the
other person.  In fact, they can commit many times creating multiple
versions before pushing any changes and make the changes visible to
the other person.  An obvious question is when one should commit
and when one should push.

The answer to the first question (when to commit) is simple: commit
anytime as one wishes.  Since commit does not affect the shared
repository, it is acceptable committing changes that are incomplete or
even contain errors (i.e., ``bugs''). Committing creates a new version
with a message; this new version is searchable by the message.  When
one decides the changes are ``good enough'' to stay for now, it is
time to commit and create a new version.  One may experiment different
methods implementing a feature with different versions. As long as the
versions are not pushed, the experiments do not cause any problem to
the other people sharing the same {\tt github} repository.  Version
control cannot help if one does not commit. Thus, a good rule is
``when in doubt, commit''.

\label{page:whengitpush}
The answer to the second question (when to push) is a little more
complex because the pushed changes are visible by the other people.
The general rule about pushing is ``Do you want the other people to
see your changes?''  If the answer is yes, then push the changes.  If
the answer is no, then do not push yet.  Now, the question becomes
``When would you like people to see the changes?''  Usually, the
pushed changes should be functional and fully debugged.  Incomplete or
buggy changes should not be pushed (unless they are needed by some
other people to complete or to debug).  Sometimes, several people
working on related things and the push by each individual is
incomplete. Instead, they need to coordinate their pushes so that
their work can be integrated.
Page~\pageref{section:git:branches} will talk about branches as a way
to push changes without directly affecting the other people.

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/githubcollaborate.png}}
\caption{Workflow of two people upading the same repository in {\tt github}.}
\label{fig:githubcollaborate}
\end{figure}

In most cases, no problem occurs when two or more people modify the
same remote repository. If one person modifies a file and another
person modifies a different file, {\tt git} simply takes the changes
by both people in the latest versions (typically called ``merge'' the
changes).  Even if two people modify the same file, {\tt git} may
still be able to add the changes from both people.  In rare cases,
however, {\it conflicts} may occur when two people modify the same
file and the changes are too similar for {\tt git} to determine what
to do.  Conflicts appear in the the following markers.

\marginnote{The primary reason of conflicts is the lack of
  communication and coordination. Thus, the best way to avoid
  conflicts is to improve communication among the people modifying the
  same {\tt github} repository.}

\begin{verbatim}
<<<<<<< 
content from one version
=======
content from the other version
>>>>>>> 
\end{verbatim}

\index{git!push}
\index{git!pull}

Conventionally, the person that wants to push later is responsible
discovering and resolving conflicts by doing {\tt git pull} before
{\tt git push}.  To resolve conflicts, the person that discovers
conflicts should examine the differences and determines which to keep
and which to discard.

  \index{git!pull}
  \index{git!push}
A few general rules can reduce the chances of conflicts:
First,  communicate and coordinate with collaborators often.
Do {\tt git pull} and {\tt git push} often so that conflicts can
  be discovered earlier when only a few lines of conflicts exist.
 In order to do {\tt git push} often, it is imperative to focus
  on one specific problem (e.g., adding one feature, or fixing one
  bug) at any moment, finish the work, and then push it.

  \marginnote{How often should one do {\tt git pull} and {\tt git
      push}?  The answer depends on the number of collaborators and
    the activites. If there are many collaborators and they are very
    active pushing changes, doing {\tt git pull} more than once a day
    and {\tt git push} at least once a week would be reasonable. }

  A common mistake among beginning {\tt git} users is to do several
  things simultaneously and take too long to finish any of them.
  During the time, these users cannot do {\tt git push} because the
  incomplete work would break others' changes. When they do {\tt git
    push} finally, many things have changed in the repositories by
  other users and conflicts likely occur. Resolving these conflicts
  takes a lot of efforts.  The situation can easily become worse and
  worse: When these beginners discover that {\tt git push} creates
  conflicts, they hesitate to do {\tt git push}. Consequently, they do
  {\tt git push} less and less often and wherever they do, more and
  more conflicts occur.  Eventually, they are so afraid that they stop
  doing {\tt git push} completely. They no longer contribute and will
  soon be released from the projects.

\section{Branches}
\label{section:git:branches}

So far all changes occur on the {\it master} branch. This is evident
because the output of every {\tt git commit} command shows ``master''.
There is only one branch, the master branch.  Modifying the master
branch direclty is actually not recommended. Instead, the master
branch should be reserved for the stable versions (also called the
{\it release versions}) for people outside the development team.

\index{integer partition} Page~\pageref{page:whengitpush} said one
should not push buggy code. This is restricted to the master branch.
If multiple branches are used, it is acceptable pushing buggy code to
some branches for collaborators to inspect.  This section uses {\it
  integer partition} as an example showing how branches may be
used. Integer partition means breaking a positive integer into the sum
of several positive integers. Usually, the original number itself is
also an acceptable partition. More details about integer partition can
be found in Chapter 14 of ``Intermediate C
Programming''~\cite{Lu2015IntermediateCProgramming} and Section 9.3 of
``Discrete and Combinatorial
Mathematics''~\cite{Grimaldi2003DiscreteandCombinatorial}.  This is
the subject for an entire book~\cite{Andrews2004IntegerPartitions}.


Below are some example integer partitions:

\begin{verbatim}

1 = 1    2 = 1 + 1    3 = 1 + 1 + 1      4 = 1 + 1 + 1 + 1
           = 2          = 1 + 2            = 1 + 1 + 2
                        = 2 + 1            = 1 + 2 + 1
                        = 3                = 1 + 3
                                           = 2 + 1 + 1
                                           = 2 + 2
                                           = 3 + 1
                                           = 4
\end{verbatim}

\marginnote{Another common mistake among beginning {\tt git} users is
  that they do not merge branches. They keep changing their own
  branches.  They want to show to their collaborators that they are
  contributing by frequently pushing improvements to the repositories.
  However, if the improvements stay in the branches that are not merged,
  these improvements are not actually useful.}

\index{git!branch}

Imagine that one wishes to write a program that receives a positive
integer and prints all partitions.  The {\tt git branch} command shows
the current branch. Since no new branch has been created yet, it shows
the master branch

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git branch
* master
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

If a name is given after {\tt git branch}, a new branch is
created. The following command creates a new branch called {\tt
  partition}.

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git branch partition
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\index{git!checkout}
To change to the newly created branch, use the {\tt git checkout} command:

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git checkout partition
Switched to branch 'partition'
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

The {\tt git branch} command shows two branches and
the current working branch is called {\tt partition}.

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git branch
  master
* partition
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\index{git!add}
\index{git!commit}
\index{git!push}

This is the first version of the program:

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\thischapterpath/code/partition1.py}
\end{tt}
\nolinenumbers

This file is called {\tt partition.py} but the name is not restricted
by the branch's name.  This file can be added to the local repository
using the {\tt git add} and {\tt git commit} commands:

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git add partition.py 
$ git commit -m "add the program for integer partition" partition.py 
[partition 810a670] add the program for integer partition
 1 file changed, 29 insertions(+)
 create mode 100755 partition.py
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

Even though the {\tt partition} branch has already been created earlier,
it is known only locally and it  does not exist in the remote repository.
Thus, the {\tt git push} command has to specify the new name of the branch
by adding {\tt origin}.
The command is

\index{git!push origin}

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5.5in}|}\hline
\begin{verbatim}
$  git push origin partition
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 584 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
remote: 
remote: Create a pull request for 'partition' on GitHub by visiting:
remote:      https://github.com/yhluprog/pythonexamples/pull/new/partition
remote: 
To https://github.com/yhluprog/pythonexamples.git
 * [new branch]      partition -> partition
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\clearpage

On {\tt github} website, the new branch can be seen:

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github12.png}}
\caption{A new branch has been added to {\tt github}.}
\label{fig:github12}
\end{figure}

The file {\tt partition.py} is available only in the {\tt partition}
branch, not in the {\tt master} branch, as shown in
Figure~\ref{fig:github134}.

\begin{figure}[h] \centering
   \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github13.png}}
   \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github14.png}}
\caption{(a) The file {\tt partition.py} is in the {\tt partition}
  branch.  Also, {\tt github} says, ``This branch is 1 commit ahead of
  master.''.  (b) The file {\tt partition.py} is not in the {\tt
    master} branch.}
\label{fig:github134}
\end{figure}

\clearpage

The Python file is called {\tt partition.py}; the local and the remote
branches are called {\tt partition}.  There is no reason why they must
have the same name.  The following steps show how to rename the file.
by using the {\tt git mv} command ({\tt mv} means move). Of course,
this has to be followed by the {\tt git commit} and the {\tt git push}
commands.

\index{git!commit}
\index{git!push}
\index{git!mv}

\clearpage
\vspace{0.2in}
\noindent
\begin{tabular}{|p{5.5in}|}\hline
\begin{verbatim}
$ git mv partition.py intpart.py
$ git commit -m "rename the file" intpart.py 
$ git commit -m "deleted" partition.py
[partition 872d9c3] rename the file
 1 file changed, 30 insertions(+)
 create mode 100755 intpart.py
$ git push origin partition
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 574 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/yhluprog/pythonexamples.git
   810a670..872d9c3  partition -> partition
[partition 4b61bbf] deleted
 1 file changed, 29 deletions(-)
 delete mode 100755 partition.py
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}


It is possible to have different names for the local and the remote
branches but there is no obvious advantages and can cause unnecessary
confusion.  Thus, they will be kept the same.

A branch can also have multiple commits and pushes. The {\tt
  intpart.py} program uses both odd numbers and even numbers. It will
give users the options to use only odd numbers or only even numbers by
specifying {\tt -o} or {\tt -e} flag. Obviously, if {\tt -e} is used,
only even numbers can be partitioned. The new program is listed below:

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\thischapterpath/code/partition2.py}
\end{tt}
\nolinenumbers

When partitioning {\tt 4}, is {\tt 1 + 1 + 2} considered the same as
{\tt 1 + 2 + 1}, as well as {\tt 2 + 1 + 1}? The program {\tt
  intpart.py} treats them as different partitions.  The next change is
to have the option whether orders matter. If the order does not matter
(i.e., {\tt 1 + 1 + 2}, {\tt 1 + 2 + 1}, and {\tt 2 + 1 + 1} are
considered as equivalent or duplicates), one simple way to eliminate
duplicates is by restricting the latter numbers must not be smaller
than earlier numbers.  This eliminates {\tt 1 + 2 + 1} and {\tt 2 + 1
  + 1} because they do not meet the requirement.
The new program is listed below:

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\thischapterpath/code/partition3.py}
\end{tt}
\nolinenumbers

\index{git!checkout}
\index{git!merge}
\index{git!branch!-d}

\marginnote{Most branches should have short lives: Each branch is
  created for one specific purpose.  It is documented, developed,
  tested, committed, merged, and then deleted.}
  
Now the program is ready to be moved to the stable {\tt master}
branch.  This will be done in three steps: (1) go to the {\tt master}
branch using the {\tt git checkout} command; (2) merge the {\tt
  partition} branch to the {\tt master} branch using the {\tt git
  merge} command; (3) delete the {\tt partition} branch using the {\tt
  git branch -d} command.  The {\tt git branch} command is used to
check which branch is used right now and whether any other branch
exists.  At can be seen, the last {\tt git branch} shows only the {\tt
  master} branch.  The last command deletes the branch at {\tt github}.

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5.5in}|}\hline
\begin{verbatim}
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.
$ git branch
* master
  partition
$ git merge partition
Updating 3357bae..d9ee8e1
Fast-forward
 intpart.py | 70 +++++++++++++++++++++++++++
 1 file changed, 70 insertions(+)
 create mode 100755 intpart.py
$ git branch -d partition
Deleted branch partition (was d9ee8e1).
$ git branch
* master
$ git push
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/yhluprog/pythonexamples.git
   3357bae..d9ee8e1  master -> master
$ git push origin --delete partition
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
To https://github.com/yhluprog/pythonexamples.git
 - [deleted]         partition
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

\clearpage

\section{Pull Requests}
\index{github!pull request}

Creating a branch does not inform collaborators. This is reasonable
because a branch may have many versions that are not ready to be
shared. When a version is ready, collaborators may be informed by
using a {\it pull request}. A pull request should be initiated from a
branch other than the {\tt master} branch because the {\tt master}
should be the stable branch. A pull request may serve one or more
purposes, including (1) The version in the branch is ready to be
inspected by one or more collaborators before being merged to the {\tt
  master} branch. (2) The version needs to be integrated with the work
by collaborators. (3) The version has some problems and the person
that creates this version does not know how to solve the
problems. This person asks collaborators to help.

Suppose one wants to add another option that excludes the number itself in
integer partition. For example, to partition {\tt 5}, valid options include
{\tt 4 + 1}, {\tt 2 + 3}, and {\tt 2 + 1 + 2}; however, {\tt 5} itself is not accepted.
This person creates a new branch called {\tt partition\_not\_self}. 
The following command, with {\tt -b}, can simultaneously create a branch and switch to the
branch.

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5in}|}\hline
\begin{verbatim}
$ git checkout -b partition_not_self
Switched to a new branch 'partition_not_self'
$ git branch
  master
* partition_not_self
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}

The following code is an attempt for this option. However,
when {\tt -s} is added, no partition is printed at all.

\resetlinenumber[1]
\linenumbers
\begin{tt}
  \lstinputlisting{\thischapterpath/code/partition4.py}
\end{tt}
\nolinenumbers

The person writing this program wants to get help from a collaborator
by creating a pull request.  Figure~\ref{fig:github158} shows how to
create a pull request on {\tt github} and assign it to a collaborator.

\begin{figure}[h] \centering
 \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github15.png}}
  \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github18.png}}
\caption{(a) Create pull request on the {\tt github} website.
(b) Assign it to a specific collaborator.}
\label{fig:github158}
\end{figure}

\clearpage

A pull request can automatically mark the line-by-line changes
as shown in Figure~\ref{fig:github167}.

\begin{figure}[h] \centering
 \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github16.png}}
  \subfigure[]
{\includegraphics[width=4.5in]{\thischapterpath/figures/github17.png}}
\caption{The pull request can show the line-by-line differences.}
\label{fig:github167}
\end{figure}

The pull request can also include comments in addition to
the commit message.

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github19.png}}
\caption{The pull request allows  comments.}
\label{fig:github19}
\end{figure}

Figure~\ref{fig:github20} shows an example of a response of the pull
request. Usually, responses are in the form of suggestions to improve
code or questions for clarification.

\begin{figure}[h] \centering
{\includegraphics[width=4.5in]{\thischapterpath/figures/github20.png}}
\caption{Response of a pull request.}
\label{fig:github20}
\end{figure}



\clearpage

\section{Issues}
\index{github!issue}

\section{Release this Book}

This book is {\it continuously released}: every time
a new version is ready, it is released.

\vspace{0.2in}
\noindent
\begin{tabular}{|p{5.5in}|}\hline
\begin{verbatim}
$ git tag v0.5
$ git push --tags
Username for 'https://github.com': yhluprog
Password for 'https://yhluprog@github.com': 
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/PurdueCAM2Project/SE4ML.git
 * [new tag]         0.5 -> 0.5
\end{verbatim}
\\ \hline
\end{tabular}
\vspace{0.2in}




